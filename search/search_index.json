{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Molecular Property Prediction","text":"Predict Properties <p>Predict molecular properties like solubility, toxicity, and binding affinity from molecular structures.</p> Graph Neural Networks <p>Uses graph neural networks to understand how atoms and bonds relate to each other in molecules.</p> Model Evaluation <p>See how well your models perform with metrics like RMSE, R\u00b2, accuracy, and F1 scores.</p> Multiple Datasets <p>Works with ESOL, FreeSolv, Lipophilicity, HIV, BACE, BBBP, SIDER, and ClinTox datasets.</p>"},{"location":"#project-overview","title":"Project Overview","text":"<p>This project helps you predict properties of chemical compounds by looking at their molecular structures. It uses graph neural networks to figure out how atoms and bonds connect and what that means for the molecule's behavior.</p> <p>You can work with different types of prediction tasks:</p> <ul> <li>ESOL: How well something dissolves in water</li> <li>FreeSolv: Hydration free energy</li> <li>Lipophilicity: How a molecule distributes between oil and water</li> <li>HIV: Whether something stops HIV from replicating</li> <li>BACE: Whether something inhibits beta secretase</li> <li>BBBP: Whether something can cross the blood brain barrier</li> <li>SIDER: What side effects something might have</li> <li>ClinTox: Whether something is toxic in clinical settings</li> </ul> <p>What You Can Do</p> <ul> <li>Load data from CSV files with SMILES strings</li> <li>Turn molecules into graphs automatically</li> <li>Use different graph neural network types (GCN, GAT, etc.)</li> <li>Evaluate models and see how they perform</li> <li>Save and load trained models</li> <li>Acces models through a web interface</li> <li>Use a web interface to make predictions</li> <li>Train models for both regression and classification tasks</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"InstallationBasic ExampleWeb InterfaceFramework Architecture <pre><code># Clone the repository\ngit clone https://github.com/saisrinivas-samoju/MoleculeNet.git\ncd MoleculeNet\n\n# Install dependencies\npip install -r requirements.txt\n\n# Or install directly\npip install cirpy deepchem mango mlflow pandas plotly rdkit seaborn torch torch-geometric fastapi uvicorn\n</code></pre> <pre><code>from src.data_loader import MoleculeDataset\nfrom src.data_preprocessor import Preprocessor\nfrom src.data_splitter import DataSplitter, ShuffleSplit\nfrom src.model_architecture import MoleculeNetRegressor\nfrom src.train import setup_training\nfrom src.predict import predict_molecule\nimport torch\n\n# Load dataset\ndataset = MoleculeDataset(root='datasets/processed', \n                         name='ESOL',\n                         filepath='datasets/csv_files/delaney-processed.csv',\n                         smiles_colname='smiles',\n                         label_colname='ESOL predicted log solubility in mols per litre')\n\n# Preprocess data\npreprocessor = Preprocessor(dataset, task_type='regression')\nprocessed_dataset = preprocessor.preprocess()\n\n# Split data\nsplitter = DataSplitter()\nsplitter.set_strategy(ShuffleSplit())\ntrain_loader, val_loader, test_loader = splitter.split_data(processed_dataset, batch_size=32)\n\n# Initialize and train model\ndevice = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\nmodel = MoleculeNetRegressor(num_features=processed_dataset[0].num_features, hidden_dim=64, layer_type='gcn')\nmodel = model.to(device)\n\n# Train model\nmodel, optimizer, history, best_metrics = setup_training(\n    model=model,\n    train_loader=train_loader,\n    val_loader=val_loader,\n    device=device,\n    task_type='regression'\n)\n\n# Make prediction for a new molecule\nsmiles = \"CC(=O)OC1=CC=CC=C1C(=O)O\"  # Aspirin\nprediction = predict_molecule(model, smiles, device, task_type='regression')\nprint(f\"Predicted solubility: {prediction:.4f} log(mol/L)\")\n</code></pre> <pre><code># Start the web server\nuvicorn app:app --reload\n\n# Then open http://localhost:8000 in your browser\n# You can enter SMILES strings or compound names to get predictions\n</code></pre> <pre><code>graph TD\n    A[Data Loading] --&gt; B[Data Preprocessing]\n    B --&gt; C[Model Training]\n    C --&gt; D[Model Evaluation]\n    D --&gt; E[Prediction]\n\n    F[SMILES Encoding] --&gt; B\n    G[Molecular Graph Construction] --&gt; B\n    H[Feature Extraction] --&gt; B\n\n    C --&gt; I[Model Saving]\n    I --&gt; J[Model Registry]\n    J --&gt; K[Web API]\n    K --&gt; E\n</code></pre>"},{"location":"#main-parts","title":"Main Parts","text":"<p>The project has a few key pieces that work together:</p> <ol> <li> <p>Data Loading: The <code>MoleculeDataset</code> class loads molecular data from CSV files. Just point it at a file with SMILES strings and property values.</p> </li> <li> <p>Data Preprocessing: The <code>Preprocessor</code> class turns SMILES strings into molecular graphs. It figures out which atoms connect to which and what features matter.</p> </li> <li> <p>Model Architecture: You can use <code>MoleculeNetRegressor</code> for regression tasks or <code>MoleculeNetClassifier</code> for classification. Both support different graph layer types.</p> </li> <li> <p>Training: The training code handles early stopping, learning rate scheduling, and tracks everything so you can see how training went.</p> </li> <li> <p>Evaluation: Check model performance with metrics. For regression you get RMSE, R\u00b2, and correlation. For classification you get accuracy, precision, recall, F1, and ROC-AUC.</p> </li> <li> <p>Prediction: Make predictions from SMILES strings. Works for single molecules or batches.</p> </li> <li> <p>Web Interface: A FastAPI web app lets you make predictions through a browser. It loads models from a registry and can handle multiple models at once.</p> </li> <li> <p>Model Registry: Keep track of all your trained models in one place. The web interface uses this to know which models are available.</p> </li> </ol>"},{"location":"#documentation-structure","title":"Documentation Structure","text":"<ul> <li>Installation: How to set things up</li> <li>User Guide: How to use each part</li> <li>API Reference: What the functions do</li> <li>Examples: Real examples you can try</li> </ul> <p>Explore the Documentation</p>"},{"location":"documentation/","title":"Project Documentation","text":"<p>Here's how to use the different parts of this molecular property prediction system.</p>"},{"location":"documentation/#data-loading","title":"Data Loading","text":"<p>Load molecular data from CSV files. The system expects SMILES strings and property values.</p> Basic UsageAvailable Datasets <pre><code>from src.data_loader import MoleculeDataset\n\n# Load data from a CSV file\ndataset = MoleculeDataset(\n    root='datasets/processed',\n    name='ESOL',\n    filepath='datasets/csv_files/delaney-processed.csv',\n    smiles_colname='smiles',\n    label_colname='ESOL predicted log solubility in mols per litre'\n)\n\nprint(f\"Loaded {len(dataset)} molecules\")\n</code></pre> <p>Here are the datasets you can use:</p> Dataset Property Type Size ESOL Aqueous Solubility Regression 1,128 FreeSolv Hydration Free Energy Regression 642 Lipophilicity Octanol/Water Distribution Regression 4,200 BBBP Blood-Brain Barrier Penetration Classification 2,039 BACE \u03b2-secretase Inhibition Classification 1,513 HIV HIV Replication Inhibition Classification 41,127 SIDER Side Effect Classification 1,427 ClinTox Clinical Toxicity Classification 1,478 <p>The <code>MoleculeDataset</code> class does a few things:</p> <ul> <li>Loads molecule data from CSV files</li> <li>Stores SMILES strings and their property values</li> <li>Converts molecules into PyTorch Geometric Data objects</li> <li>Lets you access molecules by index and check how many you have</li> </ul>"},{"location":"documentation/#data-preprocessing","title":"Data Preprocessing","text":"<p>This turns raw molecular data into graphs that neural networks can work with.</p> Preprocessing StepsFeature Engineering <pre><code>from src.data_preprocessor import Preprocessor\n\n# Initialize preprocessor\npreprocessor = Preprocessor(dataset, task_type='regression')\n\n# Preprocess the dataset\nprocessed_dataset = preprocessor.preprocess()\n</code></pre> <p>The preprocessor pulls out different features:</p> <ul> <li>Atom Features: What element it is, chirality, hybridization, whether it's in a ring, etc.</li> <li>Bond Features: Single, double, triple bonds, conjugation, ring membership</li> <li>Molecular Graphs: Nodes are atoms, edges are bonds, all with their features attached</li> </ul> <p>The preprocessing pipeline:</p> <ol> <li>Takes SMILES strings</li> <li>Converts them to molecular graphs</li> <li>Extracts features for each atom and bond</li> <li>Creates PyTorch Geometric Data objects</li> </ol>"},{"location":"documentation/#data-splitting","title":"Data Splitting","text":"<p>Split your data into training, validation, and test sets.</p> Basic SplittingAvailable Strategies <pre><code>from src.data_splitter import DataSplitter, ShuffleSplit\n\n# Initialize splitter with a strategy\nsplitter = DataSplitter()\nsplitter.set_strategy(ShuffleSplit())\n\n# Split the data\ntrain_loader, val_loader, test_loader = splitter.split_data(\n    processed_dataset, \n    batch_size=32, \n    random_seed=42\n)\n</code></pre> <p>You can use different ways to split:</p> <ul> <li>ShuffleSplit: Random splitting (default)</li> <li>ScaffoldSplit: Split based on molecular scaffolds</li> <li>TemporalSplit: Split based on time if your data has that info</li> </ul> <p>The data splitter makes sure:</p> <ul> <li>Data gets distributed properly across train, val, and test</li> <li>Batch sizes stay consistent for training</li> <li>You can reproduce splits with a random seed</li> </ul>"},{"location":"documentation/#model-architecture","title":"Model Architecture","text":"<p>You can use regression or classification models depending on what you're trying to predict.</p> Regression ModelClassification ModelAvailable Architectures <pre><code>from src.model_architecture import MoleculeNetRegressor\nimport torch\n\n# Initialize model\ndevice = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\nmodel = MoleculeNetRegressor(\n    num_features=dataset[0].num_features,\n    hidden_dim=64,\n    layer_type='gcn',\n    dropout_rate=0.2\n)\nmodel = model.to(device)\n</code></pre> <pre><code>from src.model_architecture import MoleculeNetClassifier\nimport torch\n\n# Initialize model\ndevice = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\nmodel = MoleculeNetClassifier(\n    num_features=dataset[0].num_features,\n    hidden_dim=64,\n    layer_type='gcn',\n    dropout_rate=0.2,\n    num_classes=2  # Binary classification\n)\nmodel = model.to(device)\n</code></pre> <p>You can use different graph neural network types:</p> <ul> <li>GCN: Graph Convolutional Network (default)</li> <li>GAT: Graph Attention Network</li> <li>GraphSAGE: Graph SAmple and aggreGatE</li> </ul> <p>The model classes:</p> <ul> <li>Take molecular graphs as input</li> <li>Process them through graph layers</li> <li>Output predictions (numbers for regression, class labels for classification)</li> </ul>"},{"location":"documentation/#model-training","title":"Model Training","text":"<p>Train your models with early stopping and learning rate scheduling built in.</p> Basic TrainingAdvanced Options <pre><code>from src.train import setup_training, plot_training_history\n\n# Train the model\nmodel, optimizer, history, best_metrics = setup_training(\n    model=model,\n    train_loader=train_loader,\n    val_loader=val_loader,\n    device=device,\n    learning_rate=0.001,\n    num_epochs=100,\n    patience=10,\n    task_type='regression'\n)\n\n# Plot training progress\nplot_training_history(history, task_type='regression')\n\nprint(f\"Best validation metrics: RMSE={best_metrics['RMSE']:.4f}, R\u00b2={best_metrics['R2']:.4f}\")\n</code></pre> <pre><code># Train with additional options\nmodel, optimizer, history, best_metrics = setup_training(\n    model=model,\n    train_loader=train_loader,\n    val_loader=val_loader,\n    device=device,\n    learning_rate=0.001,\n    weight_decay=0.0001,  # L2 regularization\n    num_epochs=100,\n    patience=10,\n    scheduler_factor=0.5,  # Learning rate reduction factor\n    scheduler_patience=5,  # Epochs before reducing learning rate\n    verbose=True,  # Print progress\n    task_type='regression'\n)\n</code></pre> <p>The training module gives you:</p> <ul> <li>Early stopping so you don't overfit</li> <li>Learning rate scheduling to help convergence</li> <li>Training history so you can see what happened</li> <li>Plots of training progress</li> </ul>"},{"location":"documentation/#model-evaluation","title":"Model Evaluation","text":"<p>See how well your model performs on test data.</p> Basic Evaluation <pre><code>from src.evaluate import evaluate_model\nimport matplotlib.pyplot as plt\n\n# Evaluate on test data\ntest_metrics, test_predictions, test_actual = evaluate_model(\n    model, test_loader, device, task_type='regression'\n)\n\n# Print metrics\nprint(\"Test metrics:\")\nfor metric_name, metric_value in test_metrics.items():\n    print(f\"  {metric_name}: {metric_value:.4f}\")\n\n# Visualize predictions vs actual values\nplt.figure(figsize=(8, 6))\nplt.scatter(test_actual, test_predictions, alpha=0.5)\nplt.plot([min(test_actual), max(test_actual)], [min(test_actual), max(test_actual)], 'r--')\nplt.xlabel('Actual Values')\nplt.ylabel('Predicted Values')\nplt.title('Test Set: Predicted vs Actual Values')\nplt.grid(True, alpha=0.3)\nplt.show()\n</code></pre> <p>The evaluation module calculates:</p> <ul> <li>For Regression: RMSE, MAE, R\u00b2, Pearson correlation</li> <li>For Classification: Accuracy, precision, recall, F1-score, ROC-AUC</li> </ul>"},{"location":"documentation/#model-saving-and-loading","title":"Model Saving and Loading","text":"<p>Save trained models so you can use them later or deploy them.</p> Saving a ModelLoading a Model <pre><code>from src.model_utils import save_model\nimport os\n\n# Ensure model directory exists\nos.makedirs('models', exist_ok=True)\n\n# Create model info dictionary\nmodel_info = {\n    'num_features': dataset[0].num_features,\n    'hidden_dim': 64,\n    'layer_type': 'gcn',\n    'dataset': 'ESOL',\n    'target_column': 'ESOL predicted log solubility in mols per litre',\n    'task_type': 'regression'\n}\n\n# Save the model\nsave_model(\n    model=model,\n    optimizer=optimizer,\n    model_info=model_info,\n    metrics=test_metrics,\n    model_path='models',\n    model_name='esol_gcn'\n)\n</code></pre> <pre><code>from src.model_utils import load_model\n\n# Load the model\nloaded_model, loaded_info, loaded_metrics = load_model(\n    'models/esol_gcn_full.pt', device, task_type='regression'\n)\n\nprint(f\"Loaded model info: {loaded_info}\")\nprint(f\"Loaded model metrics: {loaded_metrics}\")\n</code></pre> <p>The model utilities let you:</p> <ul> <li>Save models with all their metadata</li> <li>Load models back easily</li> <li>Store model architecture, weights, and performance metrics together</li> <li>Seperate model files from their configuration</li> </ul>"},{"location":"documentation/#making-predictions","title":"Making Predictions","text":"<p>Make predictions for new molecules using SMILES strings.</p> Single Molecule PredictionMultiple Molecule Predictions <pre><code>from src.predict import predict_molecule\n\n# Predict property for a single molecule using SMILES\nsmiles = \"CC(=O)OC1=CC=CC=C1C(=O)O\"  # Aspirin\n\n# For regression\nprediction = predict_molecule(model, smiles, device, task_type='regression')\nprint(f\"Predicted solubility: {prediction:.4f} log(mol/L)\")\n\n# For classification\nclass_label, class_prob = predict_molecule(model, smiles, device, task_type='classification')\nprint(f\"Predicted class: {class_label} with probability {class_prob:.4f}\")\n</code></pre> <pre><code>from src.predict import predict_molecules\nimport pandas as pd\n\n# List of SMILES strings\nsmiles_list = [\n    \"CC(=O)OC1=CC=CC=C1C(=O)O\",  # Aspirin\n    \"CN1C=NC2=C1C(=O)N(C(=O)N2C)C\",  # Caffeine\n    \"CC(C)CC1=CC=C(C=C1)C(C)C(=O)O\"  # Ibuprofen\n]\n\n# Predict properties for multiple molecules\n# For regression\npredictions, _ = predict_molecules(model, smiles_list, device, task_type='regression')\n\n# For classification\npredictions, probabilities, _ = predict_molecules(model, smiles_list, device, task_type='classification')\n\n# Create results dataframe\nresults = pd.DataFrame({\n    'SMILES': smiles_list,\n    'Predicted': [f\"{pred:.4f}\" for pred in predictions]\n})\n\nprint(results)\n</code></pre> <p>The prediction module lets you:</p> <ul> <li>Predict from SMILES strings directly</li> <li>Handle batches of molecules</li> <li>Work with both regression and classification models</li> </ul>"},{"location":"documentation/#web-interface","title":"Web Interface","text":"<p>There's a web interface you can use to make predictions without writing code.</p> Starting the ServerUsing the API <pre><code># Start the FastAPI server\nuvicorn app:app --reload\n\n# The web interface will be at http://localhost:8000\n</code></pre> <pre><code>import requests\n\n# Make a prediction via API\nresponse = requests.post(\n    'http://localhost:8000/molecule-net/predict',\n    json={\n        'query': 'aspirin',  # Can be SMILES or compound name\n        'model_ids': ['esol_solubility']  # Optional, uses all models if not specified\n    }\n)\n\nresult = response.json()\nprint(result)\n</code></pre> <p>The web interface provides:</p> <ul> <li>A browser based UI for making predictions</li> <li>Support for SMILES strings or compound names (resolves names to SMILES)</li> <li>3D molecular visualization</li> <li>Model registry to manage multiple trained models</li> <li>API endpoints for programmatic access</li> </ul>"},{"location":"documentation/#model-registry","title":"Model Registry","text":"<p>The model registry keeps track of all your trained models and makes them available through the web interface.</p> Model Registry StructureUpdating the Registry <p>The <code>model_registry.json</code> file contains information about each model:</p> <ul> <li>Model ID and name</li> <li>File path to the saved model</li> <li>Dataset and task type</li> <li>UI configuration for the web interface</li> <li>Property definitions and interpretations</li> </ul> <pre><code>from src.helper import update_model_registry\n\n# After training a model, update the registry\nupdate_model_registry()\n</code></pre> <p>The model registry:</p> <ul> <li>Tracks all available models in one place</li> <li>Configures how models appear in the web interface</li> <li>Defines what properties each model predicts</li> <li>Groups models by category for easier selection</li> </ul>"}]}